<!DOCTYPE html>
<html>
<head>
  <title>TensorFlow.js Model Training</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script src="https://www.espruino.com/js/uart.js"></script>
</head>
<body>

<pre>
Tensorflow training test
========================

Click 'Connect' to connect to your Bangle and
receive gestures when you make them with your hand.

Usage:

* Click 'Clear Gestures'
* Choose 'Wave' from the Gesture list
* Wave the hand with the Bangle on, then stop (Gesture should be shown below)
* do it again, 5 times
* Choose 'Clap' from the Gesture list
* Clap your hands then wait
* do it again, 5 times
* Choose 'Shake' from the Gesture list
* Shake your hand then wait
* do it again, 5 times
* Change 'Gesture' to 'None' (so no new gestures are recorded)
* Click 'Train'

**Note:** Gestures are saved to local storage, so if you come
back to the page all you have to do is click 'Train' to retrain
the model.

Now make a gesture and see if it's predicted properly!
</pre>

<button id="btn_getgesture">Connect</button><br/>
Gesture:
<select id="gesturetype">
  <option value="-1">None</option>
  <option value="0">Wave</option>
  <option value="1">Clap</option>
  <option value="2">Shake Hand</option>
</select>

<pre id="status">
</pre>

<button id="btn_clear">Clear Gestures</button>
<button id="btn_train">Train!</button>

  <script>
// Set up UART.js for only Bluetooth
UART.ports = UART.ports.filter(e => e.includes("Bluetooth")); // all watches are Bluetooth
UART.timeoutMax = 200; // Ensure .write returns quickly even when the Bangle is sending data constantly
// If "?dev=Bangle.js abcd" specified in URL, filter by that name
if (window.location.search) {
  let searchParams = new URLSearchParams(window.location.search);
  if (searchParams.has("dev"))
    UART.optionsBluetooth.filters=[{name:searchParams.get("dev")}];
}

const TF_OUTPUTS = 3;
const TF_NAMES = [
  "Wave",
  "Clap",
  "Shake Hand"
];
TF_NAMES[-1] = "Unknown";
let gestures = {
  0 : [],
  1 : [],
  2 : [],
};
let model;

// Handling loading/saving gestures
if (window.localStorage.getItem("GESTURES")!==null) {
  try {
    gestures = JSON.parse(window.localStorage.getItem("GESTURES"));
  } catch (e) {
    console.log("Gesture load failed");
  }
  for (var i=0;i<TF_OUTPUTS;i++)
    if (!gestures[i]) gestures[i]=[];
}
function saveGestures() {
  window.localStorage.setItem("GESTURES", JSON.stringify(gestures));
}
function getGestureState() {
  return Object.keys(gestures).map(g=>g+"=>"+gestures[g].length).join(",");
}

function setStatus(txt) {
  document.getElementById("status").innerText = txt;
}

setStatus("Gestures: "+getGestureState());

// Handle gesture info coming from Bangle.js
function onLine(l) {
  console.log("BT> Got line:", l);
  let json = UART.parseRJSON(l);
  if (json && json.t=="gesture") {
    let currentGesture = parseInt(document.getElementById("gesturetype").value);
    if (currentGesture>=0)
      gestures[currentGesture].push(json.data);
    saveGestures();
    setStatus(getGestureState()+"\n"+
       currentGesture+" => "+JSON.stringify(json));
    if (model) {
      makePrediction(json.data).then( prediction => {
        var maxv=0.5,maxi=-1;
        prediction.forEach((v,i) => {if (v>maxv) {maxv=v;maxi=i}});
        setStatus(`Prediction = ${TF_NAMES[maxi]} (${Array.from(prediction).map(v=>v.toFixed(2))})`);
      });
    }
  }
}

// Connect and ask Bangle.js to send gestures over
document.getElementById("btn_getgesture").addEventListener("click", function() {
  setStatus("Connecting");
  UART.write(`\x10reset()\n`) // clear out everything currently running
  .then(new Promise(resolve => setTimeout(resolve, 500))) // wait for a bit just to make sure
  .then(() => UART.write(`\x10Bangle.on("gesture",e=>Bluetooth.println(E.toJS({t:"gesture", data:e})));Bluetooth.println();\n`)) // x,y,z,x,y,z,...
  .then(function() {
    let connection = UART.getConnection();
    connection.removeListener("line", onLine); // remove any existing so we don't get duplicates
    connection.on("line", onLine);
    setStatus("Ready!");
  });
});
// Clear gesture state
document.getElementById("btn_clear").addEventListener("click", function() {
  gestures = {};
  for (var i=0;i<TF_OUTPUTS;i++)
    gestures[i]=[];
  saveGestures();
  setStatus("Gestures: "+getGestureState());
});
// Start training!
document.getElementById("btn_train").addEventListener("click", function() {
  setStatus("Training");
  trainModel().then(() => {
    setStatus("Finished!");
  });
});

// Converts the flat array to a padded [5,3] array for tensorflow
function dataToArray(data) {
  var a = new Array(50);
  var scale = 64;
  var records = Math.floor(data.length/3);
  // copy in data
  for (var i=0;i<records;i++)
    a[i] = [data[i*3]/scale, data[i*3+1]/scale, data[i*3+2]/scale];
  // pad out the end of the data with the last value
  let endXYZ = data.length-3;
  for (var i=records;i<a.length;i++) {
    a[i] = [data[endXYZ+0]/scale,data[endXYZ+1]/scale,data[endXYZ+2]/scale];
  }
  return a;
}

// Generate data for training from our saved gestures
function generateData() {
  const inputs = [];
  const outputs = [];
  let numSamples = 0;

  function addInputs(dataIn,dataOut) {
    dataIn.forEach(data => {
      inputs.push(dataToArray(data));
      outputs.push(dataOut);
      numSamples++;
    });
  }

  for (var i=0;i<TF_OUTPUTS;i++) {
    var out = new Array(TF_OUTPUTS);
    out.fill(0);
    out[i] = 1;
    addInputs(gestures[i], out);
  }


  // Convert the arrays into TensorFlow.js Tensors
  const inputTensor = tf.tensor3d(inputs, [numSamples, 50,3]);
  const outputTensor = tf.tensor2d(outputs, [numSamples, TF_OUTPUTS]);

  return { inputTensor, outputTensor };
}

// Define, compile, and train the model
async function trainModel() {
  console.log('Starting model training...');

  // Step 1: Define the model architecture
  model = tf.sequential();

  // Input Shape: [50, 3] -> 50 keypoints, each with 3 features (X, Y, Z)
  model.add(tf.layers.conv1d({
    inputShape: [50, 3], // [keypoints, features]
    filters: 32,         // Number of filters/feature maps
    kernelSize: 5,       // Window size to slide over the 50 keypoints
    activation: 'relu'
  }));

  // Pooling to reduce the dimensionality and provide translation invariance
  model.add(tf.layers.maxPooling1d({
    poolSize: 2,
    strides: 2
  }));

  // Another Conv1D layer to capture more complex features
  model.add(tf.layers.conv1d({
    filters: 64,
    kernelSize: 3,
    activation: 'relu'
  }));

  // Flatten the 3D output of the CNN layers into a 1D vector for the Dense layers
  model.add(tf.layers.flatten());

  // Dense Hidden Layer
  model.add(tf.layers.dense({
    units: 128,
    activation: 'relu'
  }));

  // Output Layer
  model.add(tf.layers.dense({
    units: TF_OUTPUTS, // M distinct gestures
    activation: 'softmax'
  }));

  // Step 2: Prepare the data
  const { inputTensor, outputTensor } = generateData();

  // Step 3: Compile the model
  // We specify the optimizer, the loss function, and the metrics to track.
  // The 'adam' optimizer is a good general-purpose optimizer.
  // 'meanSquaredError' is a common loss function for regression problems.
  model.compile({
    optimizer: 'adam',
    loss: 'meanSquaredError',
    metrics: ['accuracy']
  });

  // Print a summary of the model architecture
  model.summary();

  // Step 4: Train the model
  const epochs = 50; // Number of times to iterate over the entire dataset
  console.log(`Training for ${epochs} epochs...`);

  const history = await model.fit(inputTensor, outputTensor, {
    epochs: epochs,
    shuffle: true,
    callbacks: {
      onEpochEnd: (epoch, logs) => {
        // Log the loss and accuracy at the end of each epoch
        console.log(`Epoch ${epoch + 1}: Loss = ${logs.loss.toFixed(4)}, Accuracy = ${logs.acc.toFixed(4)}`);
        setStatus(`Epoch ${epoch + 1}: Loss = ${logs.loss.toFixed(4)}, Accuracy = ${logs.acc.toFixed(4)}`);
      }
    }
  });

  console.log('Training complete!');
  // Clean up Tensors to free up memory
  inputTensor.dispose();
  outputTensor.dispose();
}

// Make a prediction using our model
async function makePrediction(data) {
  console.log('Making a prediction...');

  // Step 1: Convert the JavaScript array to a 2D Tensor
  const inputTensor = tf.tensor3d([dataToArray(data)], [1,50,3]);

  // Step 2: Make the prediction using the model's predict method
  // The result will be a Tensor.
  const predictionTensor = model.predict(inputTensor);

  // Step 3: Convert the prediction Tensor back to a JavaScript array
  // The .dataSync() method is a synchronous way to get the data from the Tensor.
  // Note: For large datasets or in production, consider .data() which is asynchronous.
  const predictionArray = predictionTensor.dataSync();

  // Log the results
  console.log('Input data:', data);
  console.log('Prediction results:', predictionArray);

  // Clean up Tensors from memory
  inputTensor.dispose();
  predictionTensor.dispose();

  return predictionArray;
}

  </script>
</body>
</html>
